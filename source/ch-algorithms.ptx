<?xml version='1.0' encoding='utf-8'?>
<chapter xml:id="ch-algorithms">
    <title>Degree Bounds and Algorithms</title>
    <section>
    <introduction>
     <p>
      Our goal is to find algorithms that provide us with a description of all possible invariants in an efficient way. 
     Formally, we look for <term>minimal generators</term> for the ring of invariants <m>R^G</m> and more precisely for minimal algebra generators for
     <m>R^G</m> as an algebra over the coefficient field <m>\mathbb{K}</m>. 
</p>

<p>
  
     For our search to be successful, we need to hope that there are finitely many generators. 
     In our setup (finite groups and characteristic zero) a consequence of Hilbert's Basis Theorem is that our invariant rings are finitely generated.
     However, we will run in computational troubles if we do not have a stopping point for our search. The most effective way is to provide a 
     bound the degrees of these generators. 
</p>
     </introduction>


    <subsection xml:id="subsec-noether-degree-bound">
        <title>Noether Degree Bound</title>
        <p> A beautiful theorem of Noether establishes that we have a bound on the degree of a minimal generator independent from the action itself, 
          but just in terms of the order of the group. Moreover, we only need to look at images of monomials under the Reynolds operator.</p>
            <theorem><p> The <em>Noether Degree Bound</em> claims a ring of invariants is generated in degrees <m>\leq |G|</m> giving, 
              <me>R^G = \mathbb{K} [ R_G(\bar x^{\bar \beta}) | \; |\bar \beta| \leq |G|].</me>
            </p></theorem>
      <p>
        
      </p>

        <p>
           Noether's result is a constructive tool that provides us with a computational strategy! 
           We can apply <m>R_G</m> to all the finitely many monomials in degrees <m>\leq |G|</m> to get generators for <m>R^G</m>.
           As the number of monomials grows exponentially with the number of variables and the degree, this is more of a theoretical algorithm,
           but it does tell us that our goal is at least possible!
        </p>
    </subsection>

    <subsection xml:id="subsec-hilbert-ideal">
        <title>Hilbert Ideal</title>
        <p>
          To describe a more sophisticated approach to the search for minimal algebra generators for an invariant ring, we can actually consider an ideal instead!
          Note: for  any <m>\{ f_1,..., f_s\} \subseteq R</m>, the ideal generatd by <m>\{f_1,...f_s\}</m> 
          and the subalgebra generated by  <m>\{f_1,...f_s\}</m> over <m>\mathbb{K}</m> are very different objects.
       </p>
       <definition>
          <p>
            Let <m>J_G := R(R^G)_+</m> be the ideal in <m>R</m> generated by all positive degree invariants. 
            We call <m>J_G</m> the Hilbert Ideal for this action of <m>G</m>.
          </p>
       </definition>
        
            <theorem><p> Let <m>J_G </m> be the Hilbert ideal in <m>R</m> for the action of <m>G</m>.
            If <m>J_G = (f_1,...,f_s)</m> and every <m>f_i</m> is invariant so <m>f_i\in R^G, \,\, \forall i</m>,
            then <m>R^G = \mathbb{K}[f_1,...f_s]</m>
            </p></theorem>
       <p>
       Note that the condition that every generator is invariant is not hard to satisfy as if you have a generator that is not invariant, 
       then you can apply the Reynolds operator <m>R^G</m> to obtain a new generator that is. You can now replace the old generator 
       with this new one and still get the same ideal. What is special here is that a set of ideal generators work as algebra generators!
       Computationally, algebra generators are much harder to find as there is no guarantee to have finitely many of them. 
       However, the Hilbert Basis Theorem tells us that every ideal is finitely generated.
      </p>
    </subsection>

    <subsection xml:id="subsec-presentations">
        <title>Presentations</title>
            <p> When we say that  <m>\{f_1,...f_s\} \subseteq R</m> are minimal generators for a subring <m>S</m>, 
              we do not exclude the possibility that there is some relation, some polynomial identity, that they satisfy 
              as elements in the bigger ring <m>R</m>. We can describe the relations between the generators via a <term>presentation</term>
              of the subring. 
            </p>

                <definition>
                  <p> Let <m>S = \mathbb{K}[f_1,...f_s] \subset R</m>.
                A presentation of <m>S</m> is a map, <me>T=: \mathbb{K}[u_1,...u_s] \xrightarrow{\phi}S</me>
                such that <m>\frac{T}{\text{ker}(\phi)} \cong S</m>. We call the elements of the presentation ideal <m>\text{ker}(\phi)</m> 
               the syzygies of <m>f_i</m>'s.
                </p>
              </definition>
            
              <p>
                 Algorithms for finding generators for ideals have been intensely studied and especially in relation with the theory of Groebener bases.
                 We cannot go in the details of these tools, but what is of notice is that they are implemented in Macaulay2 
                 and so we can rely on them in our implementation. In particular, these methods are particularly effective in solving problems 
                 in Elimnination Theory.  Often the goal is to compute an ideal of relations hoping that this is less complicated than the original structure, 
                 possibly elimnating some variables.
              </p>
           
                <proposition><p>(Elimination Theory): In <m>S \otimes \mathbb{K}[u_1,...,u_s] = \mathbb{K}[x_1,...,x_n,u_1,...u_s]</m> consider the ideal,
                <me>I = (u_i - f_x(\bar x) | \, \left\langle f_i\right\rangle = S</me>
                Then,
                <me>\text{ker} (\phi)= I \cap \mathbb{K}[u_1,...,u_s]</me>
                </p></proposition>
           
                <algorithm><p> Compute a Groebner Basis <m>G</m> for <m>I</m> with elimination order for the <m>x</m>'s.
                Then, <m>G \cap \mathbb{K}[y_1,...y_s]</m>  is the Groebner Basis for <m>ker \phi</m>
                </p></algorithm>
           
    </subsection>

    <subsection xml:id="subsec-graph-of-linear-actions">
        <title>Graph of Linear Actions</title>
        <p> We can use Elimination Theory to solve our original problem of finding minimal generators for the ring of invariants.
          We first need to construct a geometric description of the action of a group <m>G</m>.
          </p>
            <definition> <p>Let <m>G</m> be a finite matrix group in <m>GL_n(\mathbb{K})</m>.
            For <m>A\in G</m> consider,
            <me> V_A = \left\{ ( \bar v, A \bar v) \mid ,v \in V \right \} \subseteq V \oplus V </me>
            Then <m>A_G = \cup_{A\in G}V_A</m> is the subspace arrangement associated to the action of G.
            </p></definition>
        
        <p>
            Note that <m>V_A</m> is a linear subspace. 
            So <m>\mathbb{I}(V_A)</m>, the set of polynomials vanishing on <m>V_A</m>, is an ideal 
            generated by linear polynomials, we call this a <term>linear ideal</term>.
  </p>

  <example>
    <p>
     Consider <me>V_{\begin{pmatrix}
            1 \amp 0 \\
            0 \amp -1 \\
            \end{pmatrix}} = \{(x_1,x_2,x_1,-x_2) \mid x_1, x_2 \in V\} = \mathbb{V}(y_1-x_1, y_2+x_2)</me>
      
    </p>
  </example>
           
    </subsection>
    <subsection xml:id="subsec-subspace-arrangement-approach">
        <title>Subspace Arrangement Approach</title>
      
           <p>
          The finite union of the subspaces <m>V_A</m>, denoted <m>\mathcal{A}</m> is a subspace arrangement, called the <term>group action arrangement</term>. 
          Via Elimination Theory, we can use the vanishing ideal of <m>\mathcal{A}</m> to recover the Hilbert Ideal.
        </p>
        
        
    
            <theorem><p>
                (Derksen): Let <m>I_G = \mathbb{I}(A_G) = \cap_{A\in G}\mathbb{I}(V_A) \subseteq \mathbb{K}[x_1,...x_n,y_1,...y_n].</m>
            Then <me>(I_G +(y_1,...,y_n)) \cap \R = J_G.</me>
            </p> </theorem>
        
        <p>
           Recent work has shown that the same approach works in the exterior algebra.
        </p>
        <p>
            <theorem><p>(Gandini) Let <m>I_G^{'} = \cap_{A\in G} \mathbb{I}(V_A) \subseteq \Lambda(\bar x, \bar y)</m>.
            Then <me>(I_G^{'} +(y_1,...y_n)) \cap \Lambda(x_1,...,x_n) = J_G^{'} : = \Lambda(\bar x)(\Lambda(\bar x)^G)_+</me>
            </p></theorem>
        </p>
        <p>
           The exterior algebra approach has computational potential. 
           Whilst Derken's approach leads to an algorithm with a long run time, 
           first experiments suggest that a fast algorithm could be implemented for skew polynomials.
           We aim to pursue this line of inquiry in the near future.
        </p>
   

    </subsection>
  </section>
  <section xml:id="sec-">
    <title>Specialized algorithms</title>
<introduction>
  
    <p>
      For some specific types of actions we have faster and simpler algorithms to find invariants. 
    </p>
</introduction>

    <subsection xml:id="subsec-AGWM">
        <title>Abelian Groups and Weight Matrices</title>
        <p>
            Every abelian group <m>G</m> can be written in its invariant factors decomposition as 
            <me>G \cong \mathbb{Z}_{d_1} \oplus....\oplus \mathbb{Z}_{d_r}, </me>
            for some unique <m>d_i</m> such that <m>d_i \mid d_{1+1}</m> where <m>i=1, \ldots , r-1</m>. 
            In multiplicative notation, 
              <me>G \cong \left\langle g_1\right\rangle \oplus...\oplus\left\langle g_r \right\rangle, \,\,\,\,\, |g_i| =d_i.</me>
            A diagonal action of <m>G</m> on <m>R= \mathbb{K}[\bar x]</m> is given by
            <me>g_i \cdot x_j = \mu_i^{w_ij}x_j</me>
            for <m> \mu_i </m> a primitive <m>d_i^{th}</m> root of unity.
            We can encod the action in the weight matrix 
            <me>W = (w_{ij})_{ij} =  
            \begin{pmatrix}
                \mu_{11} \amp \cdots     \amp   \mu_{1n}   \\
                \vdots \amp \ddots \amp      \\
                \mu_{r1}  \amp    \cdots     \amp   \mu_{rn}  
            \end{pmatrix}
            </me>
where the rows are indexed by the generators <m>g_i</m> of <m>G</m> and the columns are indexed by the variables <m>x_j</m> of <m>R</m>.
        </p>
       
            <theorem><p> A monomial is invariant under the action of <m>G</m> if an only if its exponent vector is in the kernel
              of the weigtht matrix <m> W </m>. In symbols, 
              <me>\bar x^{\bar \beta} \in R^G \iff W \bar \beta \cong (0,...,0),</me> 
              where the entry in position <m>i</m> is computed modulo <m>d_i</m>. 
              </p>
            </theorem>
        <p>
          Interpreting each row has the weight of the action of the generator <m>g_i</m>, we have that <m>g_i</m> acts 
          trivially on the monomial <m>\bar x^{\bar \beta}</m> precisely when
          <me>\mu_i^{\sum_j w_{ij} \beta_j} = 1</me>
          so <m> (W \bar \beta)_i =0</m> modulo <m>d_i</m> as <m>\mu_i</m> is a primitve <m>d_i^{th}</m> root of unity.
</p>
<p>
         We can use this result computationally. As the action is diagonal, the invariant ring is generated by monomials.
         By Noether Degree Bound we only need to examine all monomials of degree less than the order of the group <m>G</m>. 
         Then, by the theorem above, if we can sort the monomials in terms of their weigtht <m>W\bar \beta</m>, then the monomials
         with weight <m>\bar 0</m> will be invariant.
        </p>
    </subsection>
    
  </section>
</chapter>
